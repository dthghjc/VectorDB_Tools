---
alwaysApply: true
---
# VectorDB_Tools 项目设计文档

## 项目愿景 (Consolidated Vision)

本项目的目标是构建一个围绕数据处理工作流的任务管理平台，将从原始数据到 Milvus 可用数据的繁琐过程产品化、可视化。项目包含五大核心模块，构成完整的开发蓝图。

### 1. 配置中心 (Configuration)

- 管理 Milvus 连接配置。
- 管理并安全存储第三方服务（如向量模型 API）的密钥。

### 2. Schema 管理器 (Schema Management)

- 提供 UI 界面，让用户能够创建、编辑和保存 Milvus Collection 的 Schema 模板。
- 这些模板将在数据导入时被复用。

### 3. 数据导入流水线 (Data Ingestion Pipeline)

这是一个引导式的、分步骤的核心流程。
1.  **上传**: 用户上传原始数据文件。
2.  **向量化**: 用户选择向量模型，配置字段映射，系统将此作为一个后台任务来执行向量生成。
3.  **加载**: 用户选择向量化后的数据和目标 Schema, 系统将此作为另一个后台任务来执行 Milvus 数据导入。

### 4. 任务中心 (Task Management)

- 一个仪表盘 (Dashboard)，集中展示所有后台任务（向量化、数据加载、批量检索）的列表。
- 用户可以清晰地看到每个任务的状态（排队、运行中、成功、失败）、进度和日志。

### 5. 检索与评估中心 (Search & Evaluation)

- **目标**: 验证和测试向量数据的检索效果。
- **功能**:
    - 允许用户创建“测试集”（通过界面编辑或上传 prompt 文件）。
    - 用户选择一个 Collection，选择一个测试集，设置检索参数（如 `top_k`）。
    - 系统以后台任务的形式，批量执行测试集中的所有检索请求。
    - 提供一个结果页面，展示每一条 prompt 的检索结果（返回的实体、距离等）。
    - 支持将该次测试的所有结果导出为文件（如 CSV 或 JSON），便于离线分析和报告。

---

## 技术架构方案

### 一、 核心原则

- **前后端分离**: 严格遵守前后端分离原则，通过 RESTful API 进行通信。
- **异步任务处理**: 核心的、耗时的操作（数据向量化、加载）必须通过后台任务队列异步执行，前端通过 WebSocket 获取状态。

### 二、 后端架构 (Python + FastAPI)

后端是整个系统的核心，将采用分层架构并引入任务队列。

- **Web 框架**: FastAPI
- **数据库 ORM**: SQLAlchemy (配合 Alembic 进行数据库迁移)
- **数据库**: PostgreSQL
- **后台任务队列**: Celery + Redis
    - **Celery**: 业界标准的 Python 分布式任务队列，负责执行异步任务。
    - **Redis**: 作为 Celery 的 Broker (消息中间件) 和 Result Backend (结果存储)。它轻量、快速，非常适合这个场景。
- **数据验证**: Pydantic

### 三、 前端架构 (Vite + React 19)

前端负责提供流畅的用户交互体验。

- **UI 框架**: React (使用 Vite 构建)
- **样式**: TailwindCSS v4 + shadcn/ui
- **状态管理**: Redux Toolkit (RTK)
    - 用于管理全局状态，如 Milvus 连接列表。
    - 特别适用于管理任务状态：当用户提交一个任务后，可以将任务列表存入 store，并定期（轮询）更新它们的状态。
- **路由**: React Router
- **不要尝试build!!!**

### **🏗️ 前端项目架构层次**
**Vite + React 19 + React Router + shadcn/ui + TailwindCSS v4**
```
src/
├── pages/                    # 页面层 - 最终组装和业务逻辑
│   ├── auth/
│   │   ├── LoginPage.tsx     # 登录页面 - 状态管理+业务逻辑+组装
│   │   └── SignupPage.tsx    # 注册页面
│   ├── home/
│   ├── config/
│   └── ...
│
├── components/
│   ├── ui/                   # shadcn/ui 基础组件层
│   │   ├── button.tsx        # shadcn 自动生成
│   │   ├── input.tsx         # shadcn 自动生成
│   │   ├── card.tsx          # shadcn 自动生成
│   │   └── ...
│   │
│   ├── features/             # 业务功能组件层 - 纯UI组件
│   │   ├── auth/
│   │   │   ├── LoginForm.tsx # 登录表单 - 纯UI组件
│   │   │   └── SignupForm.tsx
│   │   ├── config/
│   │   └── ...
│   │
│   ├── layout/               # 布局组件层
│   │   ├── AppLayout.tsx
│   │   ├── AuthLayout.tsx
│   │   └── sidebar/
│   │
│   ├── common/               # 通用组件层
│   │   ├── LanguageSwitcher.tsx
│   │   ├── ThemeToggle.tsx
│   │   └── ...
│   │
│   └── auth/                 # 认证相关组件
│       ├── RequireAuth.tsx
│       └── AuthProvider.tsx
│
├── store/                    # 状态管理层
├── services/                 # 服务层
│   ├── api/           # HTTP请求
│   ├── cache/         # 缓存逻辑  
│   ├── validation/    # 数据验证
│   └── business/      # 业务规则
├── router/                   # 路由配置层
├── hooks/                    # 自定义hooks层
├── utils/                    # 工具函数层
└── types/                    # 类型定义层
```

### **📋 各层职责定义**

#### **1. Pages 层 (页面最终组装层)**
```typescript
// pages/auth/LoginPage.tsx
export default function LoginPage() {
  // ✅ 职责：
  // - Redux状态管理 (useAppDispatch, useAppSelector)
  // - 业务逻辑处理 (handleSubmit, error handling)
  // - 页面级副作用 (useEffect for navigation)
  // - 组装和布局UI组件
  
  const dispatch = useAppDispatch()
  const { error, loading } = useAppSelector(state => state.auth)
  
  const handleSubmit = async (data) => {
    await dispatch(loginUser(data))
  }
  
  return (
    <LoginForm 
      onSubmit={handleSubmit}
      error={error}
      loading={loading}
    />
  )
}
```

#### **2. Features 层 (业务UI组件层)**
```typescript
// components/features/auth/LoginForm.tsx
interface LoginFormProps {
  onSubmit: (data: LoginData) => void
  error?: string
  loading?: boolean
}

export function LoginForm({ onSubmit, error, loading }: LoginFormProps) {
  // ✅ 职责：
  // - 纯UI渲染
  // - 本地表单状态 (email, password)
  // - 基础表单验证
  // - 触发回调函数
  
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  
  const handleSubmit = (e) => {
    e.preventDefault()
    onSubmit({ email, password })
  }
  
  return (
    <Card>
      <form onSubmit={handleSubmit}>
        <Input value={email} onChange={setEmail} />
        <Button type="submit" disabled={loading}>
          {loading ? 'Logging in...' : 'Login'}
        </Button>
        {error && <div className="error">{error}</div>}
      </form>
    </Card>
  )
}
```

#### **3. UI 层 (shadcn基础组件层)**
```typescript
// components/ui/button.tsx (shadcn生成)
export function Button({ children, ...props }) {
  // ✅ 职责：
  // - 纯展示组件
  // - 样式和交互逻辑
  // - 无业务逻辑
  // - 高度可复用
}
```

### **🔄 数据流向**

```
用户交互 → Features组件 → 回调函数 → Pages组件 → Redux Action → API调用
                ↓
     Redux Store → Pages组件 → Props → Features组件 → UI更新
```

### **⚡ 关键设计原则**

#### **1. 单一职责原则**
- **Pages**: 只管业务逻辑和状态管理
- **Features**: 只管UI渲染和本地状态  
- **UI**: 只管基础展示和交互

#### **2. 依赖方向**
```
Pages → Features → UI
  ↓        ↓       ↓
Store   Props   Style
```

#### **3. 测试策略**
```typescript
// UI组件测试 - 测试渲染和交互
render(<LoginForm onSubmit={mockFn} />)

// Features组件测试 - 测试UI逻辑和回调
render(<LoginForm onSubmit={handleSubmit} error="test" />)

// Pages组件测试 - 测试业务逻辑和状态
const { store } = renderWithProviders(<LoginPage />)
```

### **📁 文件命名规范**

```
PascalCase.tsx    # 组件文件
camelCase.ts      # 工具函数
kebab-case/       # 目录名称
index.tsx         # 目录入口文件
```

### **🎯 最佳实践总结**

#### **DO (推荐)**
- ✅ Pages 组件处理所有业务逻辑
- ✅ Features 组件通过 props 接收数据和回调
- ✅ UI 组件完全无状态和无副作用
- ✅ 使用 TypeScript 定义清晰的接口
- ✅ 每层只依赖下一层，不跨层调用

#### **DON'T (避免)**
- ❌ Features 组件直接调用 Redux 或 API
- ❌ UI 组件包含业务逻辑
- ❌ 跨层级的直接依赖
- ❌ 在错误的层级处理错误或状态